$ nest
**********************************************************************************************
            Commands:
**********************************************************************************************
new|n [options] [name]                          Generate Nest application.
Создаёт новое Nest-приложение.
Полезные [options]:
--dry-run   - выполнить команду без внесения изменений в проект (просмотр листинга выполняемых действий)
--skip-git  - не инициализировать git-репозиторий
--skip-install - не устанавливать зависимости
--package-manager-npm/yarn  - выбор пакетного менеджера
--language-TS/JS    - выбор языка разработки

build [options] [app]                           Build Nest application.
Сборка проекта для Production
Полезные [options]:
--path      - путь к tsconfig.json
--config    - путь к nest-cli.json
--watch     - пересобирать проект при изменениях
--webpack   - использовать Webpack для сборки
--webpackPath   - путь до Webpack
--tsc       - сборка с TSC (в NestJS используется по умолчанию вместо WebPack)

start [options] [app]                           Run Nest application.
Сборка и запуск проекта
Полезные [options]:
те же, что и у bild +
--preserveWatchOutput   - не очищать консоль при сборке
--watchAssets   - следить не только за ts-файлами
--debug         - режим отладки
--exec          - путь до bin-файла node

info|i                                          Display Nest project details.

add [options] <library>                         Adds support for an external library to your project.

generate|g [options] <schematic> [name] [path]  Generate a Nest element.
Создаёт компонент по схеме <schematic> с именем <name>
Полезные [options]:
--dry-run   - выполнить команду без внесения изменений в проект
--project   - выбор проекта для monorepo
--flat      - без создания вложенной папки
--spec      - создание файла тестов
--no-spec   - не создавать файл тестов

Schematics available on @nestjs/schematics collection:
┌───────────────┬─────────────┬──────────────────────────────────────────────┐
│ name          │ alias       │ description                                  │
│ application   │ application │ Generate a new application workspace         │
│ class         │ cl          │ Generate a new class                         │
│ configuration │ config      │ Generate a CLI configuration file            │
│ controller    │ co          │ Generate a controller declaration            │
│ decorator     │ d           │ Generate a custom decorator                  │
│ filter        │ f           │ Generate a filter declaration                │
│ gateway       │ ga          │ Generate a gateway declaration               │
│ guard         │ gu          │ Generate a guard declaration                 │
│ interceptor   │ itc         │ Generate an interceptor declaration          │
│ interface     │ itf         │ Generate an interface                        │
│ library       │ lib         │ Generate a new library within a monorepo     │
│ middleware    │ mi          │ Generate a middleware declaration            │
│ module        │ mo          │ Generate a module declaration                │
│ pipe          │ pi          │ Generate a pipe declaration                  │
│ provider      │ pr          │ Generate a provider declaration              │
│ resolver      │ r           │ Generate a GraphQL resolver declaration      │
│ resource      │ res         │ Generate a new CRUD resource                 │
│ service       │ s           │ Generate a service declaration               │
│ sub-app       │ app         │ Generate a new application within a monorepo │
└───────────────┴─────────────┴──────────────────────────────────────────────┘

**********************************************************************************************
            Настройки Typescript
**********************************************************************************************

Нужно следить за тем, чтобы в tsconfig.json "боевого" проекта были следующие настройки
"strictNullChecks": true,               //строгая проверка на ноль
"noImplicitAny": true,                  //не допускать неявного any
"strictPropertyInitialization": false,  //позволяет использовать классы как интерфейсы 
                                        (не требует инициализировать все поля классов)
                                        (эта опция упрощает создание контрактов)
"skipLibCheck": true,                   //пропустить проверку типов всех файлов .d.ts (например, библиотек).

**********************************************************************************************
            Структура приложния NestJS
**********************************************************************************************
 Приложение NestJS состоит из модулей (должно иметь хотя бы один модуль).
 Этот модуль называется корневым - AppModule.
 Допускается добавлять в приложение неограниченное количество вложенных модулей.
 Модули приложения NestJS можно представить в виде древовидной структуры.
 Рекомендуется разделять модули приложения по доменным областям. 
 Микросервисы обычно состоят из одного модуля (AppModule).
 Крупные монолитные API - из трёх и более уровней вложенности.
 Модульность позволяет поддерживать чистоту приложения,
 облегчает возможность рефакторинга,
 предоставляет возможность выносить функционал модулей в отдельные микросервисы.
 Модуль объединяет в себе зависимости одной доменной области.
 @Module({
    imports:[],                     //зависимости
    oontrollers:[AppController],    //контроллеры
    providers:[AppService],         //сервисы, репозитории и прочие провайдеры
    exports:[]                      //экспортируемые провайдеры или re-export модулей
})

Когда приложение NestJS запускается, происходит построение дерева зависимостей:
собираются все импорты, контроллеры, провайдеры, начиная с корневого (AppModule).
Если разработанный модуль не импортируется, то он не будет участвовать в работе приложения.

Виды модулей:
(common) общие модули - импортируются в несколько других модулей (например, для шифрования)
-------
повторно экспортирующие - позволяют переэкспортировать модули, который были импортированы в него
    @Module({
        imports:[CommonModule],
        exports:[CommonModule],
    })
    export class AppModule{}
------
(global) глобальные модули - если провайдер (модуль) нужен во всех модулях приложения,
то его можно сделать глобальным. Это позволит использовать его во всех модулях приложения без импорта.
Глобальный модуль должен быть импортирован в корневой (узловой) модуль приложения.
    @Global()
    @Module({...})
    export class MyModule{}
-------
динамические - принимают параметры (например, для подключения к БД - порты и т.п.)
Динамический модуль представляет собой статический метод модуля, который возвращает объект следующего вида:
    {
        //global: true, - делает динамический модуль глобальным
        module:...,
        providers:...,
        exports:...,
    }
По умолчанию такие  методы принято называть:
forRoot - если планируется глобальное использование,
forFeature - если он будет использован в ограниченном scope

Пример подключения глобального динамического модуля (вызовом статического метода класса с параметрами):
    @Module({
        imports: [MyModule.forRoot('connection')],
        ...
    })

Дмнамические модули часто используются во внешних библиотеках, например, для работы с БД.

**********************************************************************************************
            Создание модулей
**********************************************************************************************
При генерации модуля из командной строки он не только создаётся, но и подключается автоматически.
$ nest generate module auth
CREATE src/auth/auth.module.ts (81 bytes)
UPDATE src/app.module.ts (308 bytes)            //подключение модуля происходит автоматически

$ nest g module top-page
CREATE src/top-page/top-page.module.ts (84 bytes)
UPDATE src/app.module.ts (383 bytes)
Создаёт и автоматически подключает модуль TopPageModule

nest g module test --flat
Создание модуля в папке src (без создания вложенной папки)

**********************************************************************************************
            Создание моделей
**********************************************************************************************
Созданием модели в виде класса с помощью CLI без создания файла тестов
(src/product/product.model/product.model.ts)
$ nest g class product/product.model --no-spec

Указывать папку,в которую должна быть помещён создаваемый файл требуется только при создании моделей.
При создании контроллеров, провайдеров и т.п. файл будет помещён в папку, соответствующую названию файла автоматически.

Описание модели в виде класса позволяет использовать декораторы.
Использование декораторов позволяет упростить валидацию, работу с БД, добавление методов моделям.

**********************************************************************************************
            Контроллеры
**********************************************************************************************
Контроллер - это точка входа в приложение, куда приходят запросы (HTTP, MQTT, RabbitMQ, Kafka, gRPC ...)
Контроллеры представляют собой классы, которые обёрнуты декоратором Controller.

Пример создания контроллера без тестов:
$ nest g controller auth --no-spec
CREATE src/auth/auth.controller.ts (97 bytes)
UPDATE src/auth/auth.module.ts (166 bytes)

 
NestJS позволяет задать в приложении глобальный префикс всему API.
Это делается в теле async function bootstrap(), находящейся в файле src/main.ts,
вызовом метода  setGlobalPrefix:
app.setGlobalPrefix('prefix')

(Глобальный префикс API удобно использовать, если Front и Back приложения работают на одном домене.
Использование глобального префикса API позволяет не использовать nginx (который умеет делать rewrite).)

Роутинг маршрутов, ведущих за пределы API, определяется в контроллерах.
Внутрь декоратора Controller можно передать путь, по которому этот класс (контроллер) будет доступен.
Рекомендация: название роута должно совпадать с названием метода контроллера, который его обрабатывает.
-------
@Controller('product')
Данный контроллер будет доступен по адресу http://domen/prefix/product, например,
http://hest.ru/api/product
------
    Методы контроллеров
------
Классы, декорируемые Controller, должны реализовывать методы (быть декорированы методами), названия которых соответствуют HTTP-глаголам:
@Get(path), @Post(path), @Delete(path),...,
path - постфикс, который будет добавлен к адресу соответствующего контроллера.
Например,
@Post('add/:id') добавит обработку POST-запроса по адресу http://hest.ru/api/product/add/id,
где id - динамический параметр.
Каждый метод контроллера должен возвращать ответ клиенту (браузеру).
"Под капотом" NestJS преобразует данные, помещаемые в ответ, в формат JSON.
Это происходит автоматически средствами фреймворка.

------
    Декораторы, доступные в контроллерах
------
@Req() - объект запроса целиком. Остальные декораторы позволяют получить его вложенные поля (свойства).
@Res() - объект ответа
@Param(key?:string) - строковый параметр запроса (например, id можно извлечь из '/:id')
@Body(key:string) - тело запроса (JSON)
@Query(key?:string) - query-параметры запроса (находятся после ?) (например, count можно извлечь из '/:id?count=5')
@Headers(name?:string) - заголовок запроса
@Session() - сессия пользователя

Контроллеры поддерживают WildCard -?,+,*,(,)
Например,
@Controller('product*s')
не видит различий между путями, в которых знак * заменён на - и на _.

@HttpCode(number) - возвращает указанный код ответа сервера (по-умолчанию для GET - 200, для POST - 201)
@Header('Cache-control', 'none') - кастомный заголовок ответа в формате ('key','value')
@Redirect('https://mydomain.ru', 301) - перенаправление на указанный адрес с кодом ответа
Перенаправление хорошо работает с MVC-приложениями,
но плохо с React (ошибка CORS).

Ограничение по поддомену:
@Controller({host: ':admin.mydomain.com'})

Возврат Promise:
async getHello():Promise<string> {
    return this.appService.getHello();
}

Возврат Observable:
getHello():Observable<string> {
return this.appService.getHello();
}

Использование Dependency Injection Response из express (!!! а не из Node)
позволяет указывать коды ответа и отправлять в качестве ответа файлы. 
Например:
import {Response} from 'express';
@Controller('products')
export class ProductController{
    @Get('/:id')
    getHello(@Res() res: Response){
        return res.sendStatus(200)
    }
}

------
    Концепция DTO (Data Transfer Object)
------
DTO - это классы, которые описывают body данных, которые будут передаваться в методы контроллеров в качестве аргументов
Рекомендация: DTO могут храниться в нескольких файлах, поэтому в папке, соответствующей каждой сущности,
желательно создавать подпапку dto, чтобы хранить все DTO конкретного контроллера в одной папке.
например, /src/auth/dto.
Используя специальный декоратор, из DTO можно автоматически получить готовую Swagger-нотацию всего API.

Т.к. методы login и register принимают одинаковые параметры, то для них достаточно одного DTO.

**********************************************************************************************
            Контроллеры
**********************************************************************************************


**********************************************************************************************
            Провайдеры
**********************************************************************************************
В роли провайдера могут выступать класс, значение, либо даже фабрика,
которые позволяют использовать модель NestJS по внедрению зависимостей
и встраиваться друг в друга, в контроллеры, в сервисы и выполнять те или иные функции:
чтение из базы данных, запрос к другим сервисам, какое-то значение,
которое мы хотим шерить (share) между несколькими контроллерами или сервисами.

@Injectable() - указание того, что можно использовать как провайдер и участвовать в дереве зависимостей.

-------
Простейший пример сервиса (провайдера) представляет собой класс,
который использует декоратор @Injectable():
-------
import {Injectable} from '@nestjs/common';

@Injectable()
export class AppService {
    getHello(){
        return 'Hello World!'
    }
}

-------
Чтобы использовать провайдер в контроллере,
достаточно добавить в его конструктор параметр, имеющий тип провайдера (выполнить DI).
В этом случае при создании инстанса контроллера будет внедрена зависимость от соответствующего сервиса (NestJS делает это "под капотом").
Если планируется использовать провайдер за пределами модуля, 
в котором он указан в свойстве providers, то его необходимо из модуля экспортировать.
Любой другой модуль, который будет импортировать модуль с экспортированным сервисом,
также сможет использовать этот сервис.
Пример использования зависимости.
-------
@Module({
    imports: [],
    controllers: [AppController],
    providers: [AppService]         //указание провайдеров, доступных модулю
})
export class AppModule {}

@Controller()
export class AppController {
    constructor(private readonly appService: AppService){}  //Dependency Injection провайдера AppService
}

--------
Циклические зависимости и ForwardRef
--------
Бывают ситуации, в которых модули взаимно импортируют друг друга и используют сервисы друг друга.
Эта циклическая зависимость может быть разрешена с помощью ForwardRef.
Возникновение циклических зависимостей свидетельствует о том,
что архитектура приложения неоптимальна и требует доработки.
В хорошо спроектированных приложениях циклические зависимости отсутствуют
и применение ForwardRef не требуется.

--------
Типы провайдеров:
--------
useClass - класс, методы которого возвращают данные
useFactory - фабрика, создающая классы с некоторыми дополнительными параметрами
useValue - фиксированная величина (например, строка с параметрами подключения)     
useExisting - позволяет создавать псевдоним уже существующего провайдера


---
Class
---
Свойство providers, описывающие провайдеры доступные модулю,
представляет собой массив объектов.
providers: [{
    provide: AppService,    //определяет название создаваемого провайдера (зависимости) 
    useClass: AppService    //класс, определяющий функционал провайдера
}]

Объекты, являющиеся элементами массива,
могут быть записаны в сокращённом виде,
если их свойства provide и useClass имеют одинаковые значения:
providers: [AppService]     //более компактная запись, равносильная предыдущей

---
Пример использования величины в качестве провайдера
---
const myValue={}
...
providers: [{
    provide: AppService,    //определяет название создаваемого провайдера (зависимости)
    useValue: myValue       //фиксированная величина (например, строка с параметрами подключения)
}]

Варианты использования useValue:
1. Подстановка конкретных величин (объектов) вместо классов позволяет упростить тестирование.
Например, заменяя реальный провайдер на объект (величину), у которого есть метод, возвращающий mock-величину.
2. Предоставление фиксированных величины (например, строка с параметрами подключения)
   providers: [{
       provide: 'MY_VALUE',    //строковое название, уникальное для приложения
       useValue: myValue       //фиксированная величина (например, строка с параметрами подключения)
   }]
    ...
    //параметр myValue получит значение useValue: myValue
    constructor(@inject('MY_VALUE') myValue:type){}

---
Factory
---
Например, используется для инициализации БД с заданными настройками.

providers: [{
    provide: 'MY_FACTORY',                   //строковое название, уникальное для приложения
    useFactory: (otherService: OtherService) =>{
        const res = otherService.loadSomething();
        return new CustomFactory(res);
    },
    inject: [OtherService],                 //внедряемая зависимость                
}]

---
useExisting
---
Позволяет переименовывать уже существующие провайдеры.
Редко используется на практике.

providers: [{
    provide: 'OtherServiceName',    //псевдоним. Определяет название создаваемого провайдера (зависимости)
    useExisting: AppService         //существующий класс, псевдоним которого будет создан
}]

------------------
Области видимости (Scopes)
------------------
    //@Injectagle({scope: Scope.DEFAULT})
DEFAULT - с пустым @Injectable() - один instance провайдера на всё приложение (Singletone)

    //@Injectagle({scope: Scope.REQUEST})
REQUEST - на каждый запрос будет создаваться отдельный instance провайдера, общий для всех сервисов, зависящих от него
Используется в chainable-классах (каждый метод класса возвращает this), например, в тестах.

    //@Injectable({scope: Scope.TRANSIENT})
TRANSIENT - каждый inject данного провайдера получит новый instance
Транзитивный - проходящий


**********************************************************************************************
            Работа с базой данных
**********************************************************************************************

Для работы с переменными окружения (.env) необходимо установить зависимость:
$ npm i @nestjs/config

Внести изменения в src/app.module.ts:
import {ConfigModule} from '@nestjs/config';
...
imports: [  ..., ConfigModule.forRoot(),, ...]

        ConfigModule.forRoot() - для создания единой конфигурации для всего приложения        
        ConfigModule.forFeature() - разные .env-файлы в разных модулях

В качестве параметра принимает объект с настройками.
Если не передавать параметры в ConfigModule.forRoot(),
то по умолчанию будет использован .env-файл, расположенный в корне проекта.

Если модифицировать конструктор контроллера:
constructor(private readonly configService: ConfigService){}
то данные, хранящиеся в .env, станут доступны во всех его методах:
    this.configService.get('TEST')
