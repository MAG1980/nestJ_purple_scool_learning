https://github.com/gothinkster/realworldПроект
Real World создается с использованием разных интерфейсов и бэкэндов,
соответствующих одной и той же спецификации API.
Это позволяет тестировать их различные комбинации.

Формат ответа API:
https://realworld-docs.netlify.app/docs/specs/backend-specs/api-response-format

***********************************************************************************************
Будем разбивать проект на модули, изолирующие логику работы с отдельными сущностями:
User, Profile, Article, Comment, Tag.

Для каждой сущности будет создан отдельный модуль.
Каждый из модулей будем импортировать в корневой модуль (AppModule).
Дочерние модули могут импортировать внутрь себя другие модули,
но в большинстве случав все модули импортируются внутрь одного корневого модуля.

По умолчанию все модули, контроллеры, сервисы изолированы друг от друга,
но мы можем создавать связи между ними с помощью механизма экспорта,
а также свойств imports, controllers, providers, которые есть у каждого модуля.

В примерах, приведённых на сайте NestJS,
названия создаваемых сущностей указываются во множественном числе.

Команда
$ nest g mo tags
не только создаёт файл модуля, но импортирует созданный модуль в AppModule.

Команда
$ nest g co tags
не только создаёт файл контроллера и тестов,
но и прописывает его в зависимости TagModule - controllers: [TagController],
а также указывает url-префикс, совпадающий с названиями описываемых сущностей во множественном числе.

В каждом контроллере необходимо реализовать actions, которые соответствуют эндпойнтам API.

Если декоратору @Get() не передать префикс, то он будет соответствовать "/".

Для работы с БД в NestJS используются ORM.
ORM - «Object-relational mapping», «Объектно-реляционное отображение»,
что означает «технология программирования,
которая связывает базы данных с концепциями объектно-ориентированных языков программирования».

ORM — прослойка между базой данных и кодом,
которая позволяет созданные в программе объекты складывать/получать в/из БД.

Установим библиотеку TypeORM:
$ pnpm i typeorm

Установим пакет-обёртку, входящий в состав NestJS,
позволяющий работать с TypeORM в NestJS (регистрировать TypeORM как модуль в NestJS):
$ pnpm i @nestjs/typeorm

Для настройки подключения TypeORM к БД служит файл src/ormConfig.ts.
Также нужно импортировать TypeOrmModule.forRoot(ormConfig) в AppModule.
Другим вариантом, позволяющим использовать переменные окружения,
является регистрация TypeOrmModule с помощью метода forRootAsync:
    TypeOrmModule.forRootAsync({
        imports: [ConfigModule],
        inject: [ConfigService],
        useFactory: getPostgresConfig,
    }),


//Ошибка PostgresDriver.loadDependencies
Для работы с БД Postgres в NestJS необходимо установить библиотеку:
$ pnpm i pg



***********************************************************************************************
            TypeORM
***********************************************************************************************

TypeORM использует декораторы:
@Entity()   - сущность (Model в других ORM) - репрезентация таблицы в БД
@PrimaryGeneratedColumn    - primary key autoincrement
@Column     - столбец

ORM процесс создания таблиц в БД и работу с этими таблицами берёт на себя.
ORM даёт возможность работать с таблицами БД как с Class Instance.
Достаточно только описать её таблицы с помощью моделей (@Entity).

Модели сущностей принято хранить в папках entities.
Файлы сущностей (моделей) должны экспортировать class TableNameEntity.
Названия таблиц БД должны соответствовать именам сущностей во множественном числе.
Для этого название класса тоже должно содержать название сущности во множественном числе,
т.к. именно от названия экспортируемого класса зависит название создаваемой TypeORM таблицы в БД, например,
export class TagsEntity создаст таблицу с названием tags.
Но можно сделать лучше!
Декоратор @Entity принимает объект options с свойством name, значение которого соответствует названию создаваемой 
таблицы:
    @Entity({name:'tags'})

Для корректной работы TypeORM (чтобы ORM находила все модели в папках проекта)
в src/ormconfig.ts или src/configs/postgres.config.ts необходимо добавить свойства
    entities: [__dirname + '/../**/*.entity{.ts,.js}'],
    synchronize: true,
которое позволит TypeORM корректно работать как в development (TS), так и в production (JS),
ведь после транспилляции название папки проекта изменяется с src на dist,
а также расширение файла изменяется с .ts на .js.

    entities: [__dirname + '/../**/*.entity{.ts,.js}']
равносильно
    entities: ["dist/**/*.entity{.ts,.js}", "src/**/*.entity{.ts,.js}"],

synchronize: true заставляет TypeORM при каждом запуске приложения читать все сущности
и создавать таблицы в БД для тех из них, для которых таблицы ещё не созданы,
т.е., чтобы создать недостающие таблицы достаточно перезапустить приложение.
Для production-режима synchronize: true не подходит, нужно устанавливать synchronize: false