https://github.com/gothinkster/realworldПроект
Real World создается с использованием разных интерфейсов и бэкэндов,
соответствующих одной и той же спецификации API.
Это позволяет тестировать их различные комбинации.

Формат ответа API:
https://realworld-docs.netlify.app/docs/specs/backend-specs/api-response-format

***********************************************************************************************
Будем разбивать проект на модули, изолирующие логику работы с отдельными сущностями:
User, Profile, Article, Comment, Tag.

Для каждой сущности будет создан отдельный модуль.
Каждый из модулей будем импортировать в корневой модуль (AppModule).
Дочерние модули могут импортировать внутрь себя другие модули,
но в большинстве случав все модули импортируются внутрь одного корневого модуля.

По умолчанию все модули, контроллеры, сервисы изолированы друг от друга,
но мы можем создавать связи между ними с помощью механизма экспорта,
а также свойств imports, controllers, providers, которые есть у каждого модуля.

В примерах, приведённых на сайте NestJS,
названия создаваемых сущностей указываются во множественном числе.

Команда
$ nest g mo tags
не только создаёт файл модуля, но импортирует созданный модуль в AppModule.

Команда
$ nest g co tags
не только создаёт файл контроллера и тестов,
но и прописывает его в зависимости TagModule - controllers: [TagController],
а также указывает url-префикс, совпадающий с названиями описываемых сущностей во множественном числе.

В каждом контроллере необходимо реализовать actions, которые соответствуют эндпойнтам API.

Если декоратору @Get() не передать префикс, то он будет соответствовать "/".

Для работы с БД в NestJS используются ORM.
ORM - «Object-relational mapping», «Объектно-реляционное отображение»,
что означает «технология программирования,
которая связывает базы данных с концепциями объектно-ориентированных языков программирования».

ORM — прослойка между базой данных и кодом,
которая позволяет созданные в программе объекты складывать/получать в/из БД.

Установим библиотеку TypeORM:
$ pnpm i typeorm

Установим пакет-обёртку, входящий в состав NestJS,
позволяющий работать с TypeORM в NestJS (регистрировать TypeORM как модуль в NestJS):
$ pnpm i @nestjs/typeorm

Для настройки подключения TypeORM к БД ранее служил файл src/ormConfig.ts.

Также нужно импортировать TypeOrmModule.forRoot(ormConfig) в AppModule.
Другим вариантом, позволяющим использовать переменные окружения,
является регистрация TypeOrmModule с помощью метода forRootAsync:
    TypeOrmModule.forRootAsync({
        imports: [ConfigModule],
        inject: [ConfigService],
        useFactory: getPostgresConfig,
    }),


//Ошибка PostgresDriver.loadDependencies
Для работы с БД Postgres в NestJS необходимо установить библиотеку:
$ pnpm i pg



***********************************************************************************************
            TypeORM
***********************************************************************************************

-----------------------
    Настройка CLI
-----------------------
https://typeorm.io/using-cli

Миграции предназначены для выполнения в production-mode, т.е. в JavaScript.

Команды typeorm migration:create и typeorm migration:generate будут создавать .ts файлы,
если не передать "флаг" -o. 
Команды migration:run и migration:revert работают только с .js файлами,
поэтому, файлы typescript необходимо скомпилировать перед выполнением этих команд.
В качестве альтернативы можно использовать ts-node в сочетании с typeorm для запуска .ts файлов миграции.

Чтобы не выполнять сборку проекта (преобразование файлов в JS) перед каждой CLI-командой,
относящейся к миграциям,
в TypeScript необходимо использовать ts-node в сочетании с typeorm для запуска файлов миграции .ts.
    $ npx typeorm-ts-node-commonjs migration:run -- -d path-to-datasource-config
где -d - alias для пути к файлу DataSource
    path-to-datasource-config - путь к файлу, по умолчанию экспортирующему DataSource.

Для удобства использования CLI необходимо добавить в package.json скрипты:
"typeorm": "typeorm-ts-node-commonjs",
"mg:create": "typeorm migration:create ./src/migrations/migration",                     - создание миграции
"typeorm_ts": "npx typeorm-ts-node-commonjs  -d ./src/configs/postgres.config.ts",      - псевдоним для 
                                                                                            использования typeorm в сочетании с ts-node
"mg:generate": "npm run typeorm_ts -- migration:generate ./src/migrations/migration",   - генерация миграции
"mg:run": "npm run typeorm_ts -- migration:run",                                        - выполнение миграции
"mg:revert": "npm run typeorm_ts -- migration:revert"                                   - отмена последней миграции

TypeORM использует декораторы:
@Entity()   - сущность (Model в других ORM) - репрезентация таблицы в БД
@PrimaryGeneratedColumn    - primary key autoincrement
@Column     - столбец

ORM процесс создания таблиц в БД и работу с этими таблицами берёт на себя.
ORM даёт возможность работать с таблицами БД как с Class Instance.
Достаточно только описать её таблицы с помощью моделей (@Entity).

Для подключения TypeORM в NestJS необходимо импортировать TypeOrmModule в AppModule,
вызвав у TypeOrmModule метод forRoot, которому передать объект,
содержащий настройки подключения к БД:
@Module({
    imports: [
        TypeOrmModule.forRoot({
            type: 'mysql',
            host: 'localhost',
            port: 3306,
            username: 'root',
            password: 'root',
            database: 'test',
            entities: [],
            synchronize: true,
            }),
    ],

Получить данные из фала .env можно вызовом метода get('имя переменной') у экземпляра ConfgService.
Чтобы не создавать лишних сущностей обычно используется инъекция зависимости
от ConfigService в параметрах функции.

Для получения конкретных значений параметров подключения к БД из .env необходимо
вместо метода forRoot у TypeOrmModule вызвать метод forRootAsync,
которому передать ссылку на асинхронную функцию,
которая получает значения из .env с помощью инъекции зависимости от ConfigModule в параметрах функции.

Этих настроек подключения к БД достаточно для получения возможности использования
паттерна Репозиторий в сервисах проекта.

--------------------------------------------
    Создание модуля для подключения к БД и DataSource 
--------------------------------------------
Для работы с миграциями потребуется объект DataSource.
Чтобы избежать дублирования кода создадим его в файле src/configs/postgres.config.ts
Для получения доступа к переменным окружения (.env) установим пакет dotenv и вызовем его функцию config():
$ pnpm i dotenv

import { config } from 'dotenv';
config();

Создадим instance ConfigService (в AppModule ConfigModule должен быть подключён глобально - .forRoot({isGlobal: true})),
чтобы с помощью него получать значения переменных окружения.
Создадим объект с настройками подключения на основе переменных окружения
const configOptions: PostgresConnectionOptions = {
    type: configService.get('DB_TYPE'),
    host: configService.get('DB_HOST'),
    port: configService.get('DB_PORT'),
    database: configService.get('POSTGRES_DB_NAME'),
    username: configService.get('POSTGRES_DB_USERNAME'),
    password: configService.get('POSTGRES_DB_PASSWORD'),
    entities: [__dirname + '/../**/*.entity{.ts,.js}'],
    synchronize: false,
    migrations: [__dirname + '/migrations/**/*{.ts,.js}'],
}

Экспортируем фабричную функцию, которая будет возвращать объект с настройками подключения для использования в 
настройках TypeOrmModule.forRootAsync(), импортируемого в DatabaseModule. 
export const getPostgresConfig = async (
  configService: ConfigService,
): Promise<PostgresConnectionOptions> => (configOptions);



----------------------------------------------------------------------------------------------
    Подключение к БД без явного импорта TypeOrmModule в AppModule (асинхронный провайдер) 
----------------------------------------------------------------------------------------------

Чтобы установить соединение с БД необходимо создать кастомный асинхронный провайдер,
имеющий свойство useFactory, которое является асинхронной функцией,
возвращающей Promise DataSource с использованием new DataSource().initialize() из typeorm пакета.

Объявленный провайдер необходимо зарегистрировать в DataBaseModule и экспортировать из него,
чтобы он стал доступен другим модулям, которые будут импортировать DataBaseModule.

После импортирования DataBaseModule в AppModule
провайдер подключения к БД станет доступен в конструкторе AppModule и других модулей,
импортирующих AppModule,
с использованием декоратора @Inject(значение свойства provide провайдера подключения к БД).

Каждый класс, зависящий от DATA_SOURCE поставщика асинхронности,
будет ждать, пока Promise не будет разрешен.

В конструктор каждого класса, использующего DATA_SOURCE необходимо передавать @Inject(DATA_SOURCE).

https://www.youtube.com/watch?v=O_q4I6T9IRM


В корневом каталоге создадим папку /migrations, в которой будут храниться файлы миграций. 
--------------------------------------------
    Паттерн Репозиторий (Repository)
--------------------------------------------
TypeORM поддерживает шаблон проектирования репозитория,
поэтому у каждого объекта есть свой собственный репозиторий. 
Эти репозитории можно получить из источника данных базы данных.

Объект DataSource имеет метод getRepository, который принимает модель сущности и возвращает ей репозиторий.
Полученный репозиторий нужно предоставить (provide: название провайдера) модулю,
который должен получить возможность его использовать:
    {provide: TAGS_REPOSITORY,
    useFactory: (dataSource: DataSource) => dataSource.getRepository(TagEntity)},
т.е. поместить в массив свойства inject соответствующего модуля). 
После этого можно выполнять инъекцию зависимости (DI) от данного провайдера
в конструкторе соответствующего класса (сервиса) с помощью декоратора @Inject(название провайдера из свойства provide).

Также в NestJS (TypeORM) репозитории можно получать методом DI в конструкторе сервиса каждой сущности с помощью
передачи параметра, относящегося к дженерик-типу, и использования декоратора @InjectRepository.
    @InjectRepository принимает модель сущности, для которой создаётся репозиторий
Каждый репозиторий содержит набор методов, необходимых работать с определённой таблицей БД.

Чтобы использовать Repository из TypeORM, необходимо выполнить DI от Repository в конструкторе сервиса,
что позволит использовать методы Repository конкретной сущности для работы с таблицей БД,
соответствующей этой модели.


Модели сущностей принято хранить в папках entities, являющихся подкаталогами папок сущностей.
    сущность/entities
Файлы сущностей (моделей) должны экспортировать class TableNameEntity.
Названия таблиц БД должны соответствовать именам сущностей во множественном числе.
Для этого название класса тоже должно содержать название сущности во множественном числе,
т.к. именно от названия экспортируемого класса зависит название создаваемой TypeORM таблицы в БД, например,
export class TagsEntity создаст таблицу с названием tags.
    Но можно сделать лучше!
Декоратор @Entity принимает объект options со свойством name, значение которого соответствует названию создаваемой 
таблицы:
    @Entity({name:'tags'})

Чтобы начать использовать какую-либо сущность, нам нужно сообщить об этом TypeORM,
вставив ее в свойство entities объекта настроек подключения к БД (массив сущностей, с которыми должен работать модуль)
в метод module forRoot (forRootAsync).

Для корректной работы TypeORM (чтобы ORM находила все модели (Entities) в папках проекта)
в объект, содержащий настройки подключения к БД, например,
    src/configs/postgres.config.ts,
необходимо добавить свойство
    entities: [__dirname + '/../**/*.entity{.ts,.js}'],
которое позволит TypeORM корректно работать как в development (TS), так и в production (JS),
ведь после транспилляции название папки проекта изменяется с src на dist,
а расширение файла - с .ts на .js.

    entities: [__dirname + '/../**/*.entity{.ts,.js}']
равносильно
    entities: ["dist/**/*.entity{.ts,.js}", "src/**/*.entity{.ts,.js}"],

Свойство 
    synchronize: true
заставляет TypeORM при каждом запуске приложения читать все сущности
и создавать таблицы в БД для тех из них, для которых таблицы ещё не созданы,т.е.,
чтобы создать недостающие таблицы достаточно перезапустить приложение.

Для production-режима synchronize: true не подходит, нужно устанавливать synchronize: false,
т.к. в противном случае будет происходить уничтожение данных.

Контроллеры принимают клиентские запросы и отправляют ответы на них, используя методы сервисов.
Логика работы с БД инкапсулируется в сервисах.
Если в ответе на запрос требуется изменить отображение данных (как требует Frontend), полученных из базы, например,
добавить дополнительное свойство,
это следует выполнить в контроллере.
Если в нескольких методах контроллера будет происходить дублирование кода,
то его нужно будет вынести внутрь сервиса.

Repository - паттерн проектирования, который будет использован для работы с данными, т.к.
TypeORM реализует паттерн Repository для работы с конкретной таблицей БД.
Чтобы реализовать паттерн Repository, необходимо выполнить Dependency Injection
    constructor(@InjectRepository(TagEntity) private readonly tagRepository:Repository<TagEntity>){}
Данный конструктор реализует инъекцию зависимости от репозитория,
который сможет работать с сущностью TagEntity: InjectRepository(TagEntity).
В параметр tagRepository будет помещён враппер, который позволит работать с таблицей БД,
которая описана моделью TagEntity.
Для типизации параметра tagRepository используется Generic-type Repository.
Благодаря данному конструктору репозиторий, который может работать с сущностью TagEntity,
будет доступен через private readonly свойство tagRepository,
т.е. обращаться к нему можно будет только внутри класса, используя ключевое слово this:
    this.tagRepository.(метод ORM для работы с данными)

При использовании репозитория (Repository) нужно указать его в зависимостях модуля,
иначе NestJS будет сообщать об ошибке: "Error: Nest can't resolve dependencies of the TagsService (?). ..."

Для указания зависимостей модуля используется свойство imports:
    imports: [TypeOrmModule.forFeature([TagEntity])],

Во вложенных модулях вместо метода forRoot() нужно использовать метод forFeature(),
т.к. каждый вложенный в корневой модуль является Feature (фичей).
В качестве параметра метод forFeature принимает массив зависимостей,
содержащий все сущности, с которыми работает модуль.
Без указания зависимостей использовать Repository невозможно,
поэтому каждый модуль должен содержать строку, аналогичную этой:
    imports: [TypeOrmModule.forFeature([TagEntity])],
в которой будут только изменяться названия сущностей, с которыми работает модуль.

Опция synchronize: true не позволяет нам в достаточной мере контролировать процесс создания таблиц в БД,
особенно это опасно в production.
Данная опция непопулярна в других ORM.
Вместо неё используется механизм миграций.


-----------------------
    Миграции
-----------------------
В файле миграции описываются изменения, которые мы хотим внести в БД.
Механизм миграций заменяет систему контроля версий при работе с БД.
Каждый раз, когда мы хотим изменить БД, например, когда добавляем столбец в БД,
мы обязаны создать новую миграцию.
Это позволит откатиться на предыдущее состояние БД в случае необходимости,
а также обеспечивает хорошую наглядность.
В отличие от изменений, происходящих в БД при активированной опции synchronize: true,
механизм миграций безопасен и для production-mode.
!Рекомендуется во всех режимах опции synchronize присваивать значение false.
Чтобы задействовать механизм миграций в настройках подключения к БД необходимо активировать опцию migrations:
    migrations: [__dirname + '/migrations/**/*{.ts,.js}'],
а также опцию cli:
    cli: {
        migrationsDir: 'src/migrations',
    },

    